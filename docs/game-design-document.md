Scablanders Game Plan

Setting: The Fringe and the Scablands

Scablanders is set in The Fringe universe – a gritty sci-fi frontier where lawless outposts attract explorers, miners, mercenaries, and pirates ￼. The game takes place on the arid planet Skarem, specifically in its Scablands region. The Scablands are an expanse of rugged desert rocklands, harsh and barren, yet rumored to hide strange life and potent resources in their crevices ￼. Survival here is tougher than in most Fringe locales – “gruel and strain is no stranger in The Fringe, but the Scablands scrape at you a little more furiously than the rest” ￼. Despite the unforgiving environment, fortune-seekers converge on this wasteland whenever opportunity arises (for example, when a giant creature’s emergence once drew Drifters from all over to harvest and brawl over its bounty ￼).

At the heart of the Scablands is a dusty mining town – a last bastion of civilization on Skarem. This town features a small spaceport for off-world transport, smelting plants to process ores, gastrotech food stalls to feed hungry drifters, supply shops for gear, and even a clandestine black market in the back alleys. It serves as the player’s home base and the social hub where drifters gather to trade stories and resources. The town is persistent and will evolve over time based on player activity (e.g. new facilities might emerge as players pour wealth into the town). It’s a hardscrabble, Wild-West style settlement clinging to the edge of the desert – equal parts opportunity and danger.

In this lore-rich setting, Fringe Drifters (the characters from the Fringe NFT collection) are the mercenaries and prospectors for hire. Each Drifter is a unique character with a backstory and specialized skills. They roam the Fringe seeking work, and many have converged here hoping to strike it rich on Skarem. The art style and atmosphere will draw from the Fringe Drifters NFT collection’s aesthetic – a blend of retro-sci-fi and space western. Players will recognize these Drifters by their distinctive looks and gear, which echo the high-detail artwork from the NFTs. Strange creatures and resources from the compendium also populate the world (for example, the elusive Ranch Milk slime mold, native to the Scablands, which miners use to dissolve rock and extract metals ￼, or rare Linno Beetles that scurry under the sand). All these elements ground the game in the authentic lore of The Fringe, giving Scablanders a rich narrative backdrop.

Game Concept Overview

Scablanders is a casual web-based multiplayer game with an idle exploration vibe. The design emphasizes a simple but engaging gameplay loop that players can dip into for a few minutes at a time, while contributing to a shared persistent world that all players influence together. The core concept is that each player manages operations out of the mining town, assembling teams of Drifters to venture into the Scablands in search of resources and treasure. While you’re away on missions, other players’ actions can impact you – and vice versa – making the world feel alive and communal.

Key features of the game concept include:
• Shared Persistent World: All players share the same Scablands world. Resources scattered across the desert are finite and deplete as players harvest them, visible to everyone. The world state (resource levels, town development, etc.) persists between sessions. If one player mines out a vein of ore or scavenges an ancient wreck, that item is gone (until the world naturally replenishes new resources periodically). This persistence means the community of players collectively shapes the environment over time ￼. The town will grow or decline based on player activities – for example, if players deliver lots of building materials, new structures might appear in town; if banditry goes unchecked, the town might suffer shortages. All active missions launched by any player are visible on the world map in real time, so you can literally see others’ teams trekking across the desert. This transparency enables cooperative and competitive interactions.
• Asynchronous Multiplayer with Impact: While gameplay is not real-time action (no direct twitch combat), players affect each other through indirect interactions. For instance, players can hire bandits to ambush others’ expeditions or race to claim the same resource node. The outcome of missions can be influenced by these interventions, introducing a strategic PvP element without requiring synchronous combat. Over time, a light player-driven narrative emerges – alliances might form to share scouting info or to retaliate against notorious bandits, etc.
• Casual “Click & Venture” Gameplay: The interaction style is light and accessible. From the town interface, players send out teams, manage their finds, and upgrade their operations. Much of the action (exploration, travel, combat) is resolved by the game systems in the background (with some RNG and stat-based calculations), allowing players to focus on decisions and strategy. You can pop in, assign a mission or two, check what others are up to, maybe do a quick trade or hire, and log off – the game will simulate the missions in the interim. This makes it friendly to short play sessions while still feeling immersive.
• Technology: Scablanders will run entirely in the browser. The front-end is built with Phaser 3, a robust HTML5 game framework for 2D games (great for rendering maps, sprites, and UI in the browser) ￼. The back-end uses Cloudflare Workers for serverless compute at the edge, meaning the game’s API runs globally with low latency and can easily scale. We’ll leverage Cloudflare’s new Vite plugin to develop and bundle the app – this allows us to seamlessly integrate the client and server code during development and deploy them together ￼. All game logic (like mission resolutions, state updates) will execute in Cloudflare Workers, with persistent data stored via Durable Objects (Cloudflare’s mechanism for stateful coordination) and possibly KV storage or D1 database for additional persistence needs. Cloudflare Durable Objects are ideal here because they allow a single consistent instance to manage our game state across the distributed edge network ￼ – ensuring that when one player mines a resource or triggers an event, every other player eventually sees the same updated world.
• Web3 Integration (Lightweight): While the game’s economy is off-chain (using a standard in-game currency with no cryptocurrency), Ethereum wallet integration will be supported from the start for authentication and NFT-based features. Players will log in by connecting their crypto wallet and signing a message (using “Sign-In with Ethereum”, an established method of wallet authentication) ￼. This verifies ownership of their address in a secure way. The game will detect if the player owns any Fringe Drifters NFTs (the collection on OpenSea) in that wallet and, if so, special gameplay effects kick in (explained below). Notably, NFT holders can passively earn in-game currency when their Drifter is hired by others. This provides a neat bridge between the Fringe NFT community and the game without making the game itself reliant on crypto or introducing pay-to-win mechanics. All players can enjoy Scablanders for free – owning an NFT is not required, it’s just a flavorful bonus.

In summary, Scablanders aims to combine resource exploration, team management, and light player-vs-player strategy in a persistent sci-fi world. Next, we break down the gameplay loop and mechanics in detail.

Core Gameplay Loop

The core loop of Scablanders revolves around sending expeditions to gather loot and using those spoils to improve your capabilities. Below is the primary cycle players will engage in, with each step elaborated: 1. Scout – The first step is surveying the wasteland for opportunities. Players can dispatch scouting missions to explore unknown areas of the Scablands map. A scout mission might use a fast lone drifter or a specialized recon team to reveal what resources or points of interest exist in a region. When a scout returns, the fog of war on the map is lifted for that area, and any discovered resource nodes (e.g. an ore deposit, a wrecked escape pod, a Ranch Milk slime mold colony, etc.) become visible to that player. Each player’s knowledge of the map is unique to them (based on what they have scouted or learned). Intel can be a valuable commodity – players might choose to share or trade information, but that’s emergent gameplay. Scouting costs a small amount of time (and maybe currency for provisions) but yields crucial information. Essentially, scouting pushes back the frontier of the unknown. 2. Hire – With a target in mind, the player heads to the Mercenary Hall in town to hire a crew of Drifters. There will be a Mercenary Board listing available drifters-for-hire (these correspond to the NFT characters, plus possibly some NPC stand-ins if needed). Each Drifter has a name, an image (the NFT art), and a set of stats/traits (e.g. combat skill, scouting aptitude, technical know-how, speed, etc.) along with a short narrative bio. Crucially, drifters have different strengths which influence mission outcomes – “Drifters with different traits uncover different loot” in the Fringe ￼, meaning a tech-savvy drifter might be more likely to find high-tech artifacts, while a survivalist might excel at gathering food or water resources. Players will weigh which mercs to hire based on their mission needs: do you need a guard with a big gun, or a tracker who can sniff out hidden caves? Hiring a drifter costs in-game currency (a hire fee). The fee goes into the game’s economy and importantly, it gets paid out to the owner of that Drifter’s NFT (more on this in the NFT section below). The player forms a team of one or more drifters for the expedition (for initial simplicity, perhaps a fixed number like up to 3 per mission). Each drifter can only be on one mission at a time, so once hired (or currently in use by its owner), it becomes unavailable until it returns. 3. Deploy on Mission – The player sends the hired team to a specific location on the Scablands map to carry out a mission. Missions could be of various types:
• Mining/Harvesting a resource node (e.g. extract Coe-Kopum ore from a deposit ￼, gather scrap from a derelict ship, collect Ranch Milk mold samples, etc.).
• Salvage/Exploration of a ruin or cave (might yield artifacts or loot cards).
• Hunting/Encounter if a mission involves a creature or bandit hideout.
• Recon/Survey (which is basically the scout mission described earlier).
For each mission, an estimated duration is calculated based on distance and the team’s speed. For example, crossing a long stretch of the Scablands might take an hour of real time, whereas a nearby mission might complete in a few minutes. The game will use real elapsed time for missions (simulating travel and task completion), encouraging players to check back later. Players will see their team leave town on the map and head to the target. During the mission, various things can happen: they might encounter hostile creatures, environmental hazards (like a sandstorm), or bandit ambushes from other players. The mission outcome is determined by the team’s combined stats plus some randomness. The player doesn’t directly control them in battle – we simulate the encounter – but good preparation (choosing strong or skilled drifters, maybe equipping them with better gear if that becomes a feature) improves the odds. 4. Battle and Risks – Missions are not guaranteed successes. If the team encounters bandits (whether NPC raiders or other players’ hired brigands), a combat resolution occurs. This will involve comparing combat stats of the defending team vs the attacking bandit team, plus randomness. If the player’s team wins, they fend off the attackers (possibly with some injuries or time loss) and continue the mission. If the bandits win, they rob the expedition – stealing a share or all of the resources the team had gathered. In the worst case, the mission might be a total failure, with the team returning empty-handed (but we likely won’t permadeath the drifters; they survive to be hired another day, albeit maybe “wounded” for some cooldown). Aside from bandits, missions can fail or yield less if, say, the team lacks the skill to extract the resource efficiently or if a random disaster strikes. These risk elements ensure missions have an element of uncertainty and reward good preparation. 5. Loot & Resource Gathering – If the mission succeeds (fully or partially), the team will return to town with loot. Loot can include raw resources (minerals, organic materials, water, etc.), artifacts (special items from the old world, which might be represented similarly to the Fringe “loot cards” concept), or other valuables. The type and amount of loot depend on the mission location and the drifters’ traits. For example, a drifter with a keen eye for tech might uncover a rare gadget among scrap, whereas a brute-force miner might just haul back a large load of ore. This ties into the lore that “Loot cards are valuable resources and artifacts discovered by Drifters… Drifters with different traits uncover different loot” ￼. The variety of loot adds depth – sometimes you might get common materials useful for steady income, other times a lucky find could be an ultra-rare artifact worth a fortune or useful for a special upgrade. 6. Sell & Reward – Back in town, the player can sell the recovered resources and loot for in-game currency (let’s call it Credits for now). There will be various places to sell:
• The Smelting Plant / Market will buy raw minerals, metals, and standard resources at a going rate (supply and demand could be a future mechanic, but to start we may use fixed prices for simplicity).
• The Gastrotech Stall buys organic finds or foodstuff (like if you collected rare mushrooms or those fluid-filled Juicebox rodents mentioned in lore).
• A Traders’ Bazaar for artifacts and curios – or perhaps the Black Market if the item is sensitive. Artifacts might fetch higher prices if traded to the right NPC or might be bartered among players later.
When the player sells loot, they receive Credits which go into their balance. This is the primary way to earn money in the game. (Note: If the player chooses not to sell certain loot – perhaps to use it in crafting or quests later – they could store it in an inventory, but initially we might implement a simple flow where loot is immediately converted to currency upon mission completion to streamline the loop). 7. Upgrade & Progress – With currency in hand, the player can upgrade various aspects of their operation, which closes the gameplay loop and makes them stronger for the next cycle. Upgrades could include:
• Better Equipment: e.g. buy a more advanced vehicle or hovercraft to accompany expeditions, so travel is faster and missions take less time. Or purchase improved tools (drilling equipment, scanners) to increase yield from resources.
• Expanded Team Capacity: upgrade your personal operation to hire more drifters at once or run multiple missions in parallel.
• Drifter Training/Level-Up: possibly invest in training a favored drifter to improve their stats (though since drifters are NFT-linked and not owned by the player unless it’s their NFT, we might not allow players to permanently upgrade mercs; instead, upgrades might come from equipping them with temporary gear).
• Town Upgrades: players might collectively fund town improvements. For instance, donating funds to fortify the town’s defenses could reduce the success of bandit raids globally, or contributing materials to expand the spaceport might unlock new mission types (like off-world contracts).
• New Areas Access: Spending currency on special maps or keys that allow access to deeper Scablands or locked locations, introducing new content.
The upgrade step is essential to give players a sense of progression. They’ll start with modest means (able to hire maybe one low-level drifter and do short missions) and over time build up to tackling longer, riskier missions with expert crews, yielding bigger rewards. Then the loop repeats: with better capabilities, you send more ambitious expeditions to farther reaches of the Scablands, find more loot, and continue upgrading.

This scout → hire → mission → loot → sell → upgrade loop provides a satisfying rhythm. Scouting gives goals, hiring and missions provide adventure and risk, and loot and selling give rewards that feed back into progression. At any given time, a player might have multiple missions in flight (depending on their upgrades), can see others’ missions (to possibly react), and can take a break while the missions resolve.

Shared World and Persistent State

One of the defining features of Scablanders is the shared persistent world state. Unlike a purely single-player idle game, here all players affect a common world:
• Global Resource Map: The resources and treasures in the Scablands are finite and shared. For example, there might be a rich Coe-Kopum ore vein in a certain canyon. If one player’s crew mines it heavily, all players will see that vein run dry (it will disappear from everyone’s map once depleted). Resources will replenish periodically, but in a dynamic way – e.g. after some in-game days, new deposits might emerge in new locations (perhaps explained diegetically as meteor strikes or the shifting geology of Skarem). This means players are, in effect, cooperating and competing in an ongoing extraction of the Scablands’ wealth. We will design a regeneration system so that there are always some resources out there, but high-value finds might be rare and hotly contested when discovered.
• Town Evolution: The mining town acts as a central social and economic hub that grows over time. We plan to simulate a few town metrics (like population, wealth, security) that respond to player actions. For instance, every successful mission that brings wealth to town could contribute to a “town prosperity” score. At certain thresholds, we could trigger upgrades to the town – new NPC merchants setting up shop, the ramshackle spaceport getting a new landing pad, the saloon expanding, etc. Conversely, if players engage in a lot of banditry (robbing each other) and don’t defend the town, perhaps the town’s security rating drops and you start seeing more NPC bandit attacks or higher prices due to scarcity. This persistent evolution gives a sense that the world is changing as a result of everyone’s actions. We’ll keep the economic model simple at first (perhaps a global counter of resources delivered), but we have room to expand this simulation as the game grows.
• Visibility of Player Actions: On the world map UI, players can see markers for every ongoing mission from any player. These markers might show a team icon moving across the map. Hovering or clicking could reveal basic info like “PlayerX’s crew (3 drifters) heading to Site Alpha, ETA 5m”. This transparency makes the world feel alive and also enables strategic interaction – for example, if you see a rival heading for a big resource cache you wanted, you might hurry to send your own team or decide to intercept them with bandits. Missions in progress can also potentially be aided – perhaps in future we could allow players to send reinforcements or supplies to each other, though not in the initial version. To implement this visibility, the back-end will broadcast active mission data to clients (possibly via a real-time channel or periodic polling). This does mean concurrency – many players seeing and acting on shared data – which we will handle via Cloudflare’s Durable Objects (ensuring one authoritative server state) and possibly WebSockets for live updates ￼. Real-time consistency is important so that, for example, if a resource is mined out by someone, others don’t still see it as available. Durable Objects allow us to maintain this consistency easily by having a single instance manage the game world state that all requests funnel through for updates ￼.
• Persistent Data Storage: All game state needs to persist so that the world remembers what has happened (even if no players are online). Cloudflare Durable Objects come with built-in storage that we will use to save the state of resources, ongoing missions, and town status. We may also use Cloudflare KV storage or the new D1 database for certain data like historical logs or user inventories, but the primary live state will be in the Durable Object responsible for the world. This ensures that if the Worker restarts, it can restore state from storage and the game world persists across deployments. Essentially, the back-end will function as a tiny MMO server keeping track of the shared world.
• Cheating and Fairness: Because the authoritative state is on the server (and not on the client), players can’t cheat by modifying their client – the server will validate actions (e.g. you can’t say “I mined 100 ore” unless the server’s simulation says so). We will enforce rate-limits and perhaps require minimal proof-of-work on missions (time delays) to avoid abuse. All transactions in the world (like transferring currency to NFT owners when hired, updating resource counts) will be done server-side, preserving the integrity of the persistent world.

In summary, the persistent world means what you do matters. If a group of players over-exploit the land, everyone might have lean times until it recovers. If bandits run rampant, everyone’s profits may suffer. On the flip side, cooperative behavior could enrich the town for all. We think this will foster community discussion and emergent gameplay, as players essentially engage in a shared simulation.

Drifters: NFT Mercenaries for Hire

Drifters are the core characters in our game – drawn from the Fringe Drifters NFT collection, they double as both collectible avatars and functional game units. Here’s how drifters and NFT integration will work:
• Mercenary Profiles: Each drifter has a profile derived from its NFT metadata or lore description. This includes their name, appearance (avatar image), and a set of attributes/skills that affect gameplay. For example, a drifter might have attributes like Combat, Scavenging, Tech, Piloting, Stealth, etc., plus possibly a special trait (like “Desert Born: moves faster in Scablands” or “Ace Pilot: better mission time for far targets”). We will design a set of drifter classes or archetypes and map each NFT to one, ensuring diversity in the mercenary pool. These differences matter because, as noted earlier, different drifters excel at finding different types of loot and handling different challenges ￼. This encourages players to think about team composition.
• Mercenary Hiring Board: In the game’s town interface, players can access the hiring board listing all available drifters. All Fringe Drifter NFTs will be represented here (unless we have reasons to exclude some). We might have to fetch the NFT data from an API (OpenSea, for example) to get the list of tokens and their images/attributes. However, to simplify, we can maintain our own database of drifter stats keyed by NFT ID, and periodically sync it with on-chain data for new additions or changes. The hiring board UI will show a paginated list or maybe a roster with filters (e.g. filter by a skill or cost). Players can click a drifter to see details and then pay the hiring fee to recruit them into their current mission team.
• NFT Ownership Effects: We want to give a small perk to NFT owners without making the game imbalanced:
• Passive Earning: Whenever a player hires a drifter, the owner of that drifter’s NFT earns the hiring fee in game currency. Essentially, the in-game currency paid as wages goes into the NFT owner’s account. This happens even if the owner is offline. For example, if Alice owns the NFT #123 (a drifter named “Axel”), and Bob hires Axel for a mission at a cost of 100 Credits, then Bob spends 100 Credits (money sink for him) and Alice’s account gets +100 Credits. This models that the drifter is effectively working as a mercenary, sending earnings back to their owner/patron. It’s a fun way to integrate the NFT: you might log in one day to find that your character has been busy working for others and earned you a pile of Credits!
• Using Your Own Drifter: If a player owns one or more Drifter NFTs, they effectively have those characters available to use without paying a hire fee. Since you “own” that drifter, you don’t have to hire them from the board – they are already in your crew. This gives NFT owners a small starting advantage of having a free companion, but it’s balanced because non-owners can still hire any drifter for a fee. We will ensure that an NFT owner cannot both use their drifter and have it hired out at the same time: when you deploy your owned drifter on a mission, we’ll mark it as unavailable for hire to others until it returns. Conversely, if someone else has hired your drifter on a job, you’d have to wait until that mission is over to use them yourself. This mimics the idea that a drifter can only be in one place at a time.
• Identity and Narrative: We may allow NFT owners to input a custom nickname or lore for their drifter (subject to approval) that appears in game. This way, the NFT owner can further personalize their character. It doesn’t affect mechanics but adds to the community storytelling aspect.
• Fairness & Availability: There are a limited number of Fringe Drifter NFTs (e.g., if the collection is 10k characters, that’s the pool of mercenaries). What if more players need mercs than there are NFTs? We anticipate that initially the player base will not exceed the number of mercs, but if it does or if many mercs are “booked” on missions, we might introduce some generic NPC drifters (non-NFT) to fill gaps. Alternatively, we could allow the same drifter to be hired by multiple players in parallel only if we treat timelines separately – but that breaks the shared world immersion (two instances of same character). Instead, better to stick with one instance of each drifter. If demand is high, it could drive up wages (we could simulate a supply/demand where hiring cost increases if many mercs are all busy). For now, we’ll keep hiring cost fixed and not too high, since the currency is not scarce at start.
• NFT Detection and Wallet Integration: On the technical side, when a user logs in with their Ethereum wallet, the backend will query the blockchain (or use an API) to see if that wallet holds any tokens from the Fringe Drifters collection. This can be done by calling an NFT API endpoint (for example, using OpenSea’s API to get assets for the owner address in that collection, or using a service like Moralis which can fetch all NFT IDs owned by an address) ￼. We will retrieve the list of Drifter IDs the player owns. The game will then mark those drifters in the hiring board as “owned” (perhaps a badge next to their name) and forgo charging a fee if the player selects them for a mission. Also, any accumulated hire fees owed to the owner (from other players) will be credited to the player upon login. We will maintain a ledger in the backend for each NFT that accumulates unclaimed earnings whenever it’s hired; logging in will transfer those to the owner’s account. If a player never logs in, the currency just stays associated with that NFT or address in our database until they claim.
• Example: Suppose NFT #250 “Charger” has been hired 10 times at 50 Credits each while its owner was away. Our server would have recorded 500 Credits for the owner’s address. When the owner authenticates, the server looks up that address, finds the pending 500 Credits, and adds it to their in-game balance (and resets the pending amount). The UI would then inform them “Your drifter Charger earned you 500 Credits in contract fees while you were gone!” – a nice welcome gift.

Overall, Drifters provide a way to integrate the community’s existing NFTs into gameplay in a meaningful but not overpowering way. NFT owners essentially become stakeholders in the game’s economy (they have mercenaries for hire) and regular players get a rich selection of characters to use in their adventures. Holding a Drifter makes you part of the Fringe universe community ￼, and Scablanders will be an opportunity to further develop those characters’ stories as they go on missions and earn renown.

Missions and Player Interaction (PvE & PvP)

Missions are the heart of gameplay, and they involve both PvE (encounters with the environment or NPC foes) and indirect PvP (players affecting each other’s missions). Here we detail how missions work and how sabotage/interference is handled:
• Launching a Mission: When a player has selected a target on the map (either a known resource node or a coordinate to explore) and assembled a team of drifters, they will issue a mission start command (via the UI, e.g. clicking “Deploy”). The front-end will call a backend API like POST /api/mission/start with the mission details (team composition, target coordinates, mission type). The server will validate that the player has enough funds (to pay any hire costs), that the drifters are free, and that the target is still available (e.g. not already depleted). If all is good, the server creates a Mission record in the durable object state: it includes who the player is, which drifters are assigned, start time, estimated end time, and target info. The drifters are then marked as busy. The player’s currency is deducted for any hire fees at mission start.
• Simulating Mission Progress: The mission will progress in real time on the server. We can implement this in a couple of ways. One approach is to use Durable Object alarms or a scheduled job – basically, when a mission starts, we calculate the duration (say 10 minutes), and set an alarm/timer in the DO to trigger at mission end time. This alarm event would then execute the mission resolution logic. Alternatively, we don’t use timers but simply calculate outcomes when the player (or any player) asks for an update or when the end time passes. However, since other players might react mid-mission, we do need to process events during the mission (like an intercept occurring). So likely we will represent missions as active objects that can accept events.
• Bandit Interception (Indirect PvP): This is the primary form of player-vs-player in Scablanders’ initial version. Any player can choose to play dirty by hiring drifters as bandits to target another active mission:
• The player who wants to sabotage goes to the Black Market screen. There, they can see a list of currently active missions (with perhaps limited details – e.g. we might hide exact loot or exact team makeup, but you’ll see “PlayerX’s expedition heading northeast, arriving in 5m”). They can pick a mission and choose “Ambush this mission.” They then select some of their own drifters (or hire new ones) to form the bandit crew, and pay a fee (bandits expect payment too!). We treat this similar to launching a mission, but it’s an intercept mission with a target mission ID.
• The intercept has to catch the target before it finishes. We might implement a simple rule: you can only ambush if you start the intercept while the target is at least e.g. 50% of its time remaining (to avoid last-second snipes). Or we could allow until the very end for dramatic effect. In any case, once the bandit mission is launched, the server will mark the target mission as “contested” and associate the intercepting party with it.
• When (or if) the intercepting bandits “meet” the target, which could be at the target location or midway (we can simplify and say the conflict happens at mission’s end, i.e., as the target team is returning with loot), the server resolves a combat encounter between the two teams. This uses the drifters’ combat-related stats. For example, each drifter could contribute an attack and defense value, plus possibly special abilities. We roll some randomness as well. The outcome can be:
• Bandits Win: The attacking player’s bandits overpower the expedition. In this case, the loot is stolen. The defending player’s mission is effectively failed (or partially failed). We decide how to split the loot – likely the bandit player gets a portion (maybe 100% for now to keep it simple – they take everything the expedition would have gotten). The defending player is left with nothing from that mission except perhaps a message that they were ambushed. We might also impose a small penalty like their drifters take some time to recover (slight delay before they become available again) to simulate being wounded or stranded. The bandit drifters return to town with the loot, and that attacking player can then sell it just like any loot. Essentially, they have profiteered off someone else’s work. Banditry should be risky though:
• Bandits Lose: If the defending expedition wins the skirmish (say they had strong guards or got lucky), then the mission proceeds normally for the defender (they keep their loot and complete the mission). The attacking bandit player fails – their drifters might return empty-handed (possibly even a penalty where one could be “captured” briefly or has a cooldown). They also wasted whatever they paid to hire those bandits. This risk of failure should deter constant abuse; you wouldn’t send a weak bandit crew against a heavily armed expedition or you’ll just lose money.
• Notification: Both players get notified of the outcome: the defender sees a report like “Your team was ambushed by bandits during the return journey! They fought them off successfully.” or “Your team was ambushed and robbed by bandits!” The attacker sees “Your bandits ambushed so-and-so’s mission and looted X resources” or “Your bandit attack on so-and-so failed.”
• We will ensure the attacker’s identity may or may not be revealed. Possibly the default is anonymity (it’s the black market after all). This could be interesting because players might have to sleuth or make guesses about who is consistently hiring bandits. Alternatively, we might reveal the perpetrator to the victim to fuel rivalries. This is a game design choice; anonymity could encourage more sabotage since no direct consequences, but revealing identity could create player-driven grudges and alliances. Perhaps for community fun, we allow a bit of both: maybe anonymity initially, but if the town security is upgraded, future bandit attacks can be traced. For MVP, we might keep it anonymous.
• Direct PvP (Future): We note that the user is interested in potential direct sabotage in the future. That could include features like players directly fighting in town or setting traps on the map. For now, we will scope that out; initial release focuses on the indirect bandit PvP. Down the line, ideas include:
• Allowing players to duel or fight over resources in real-time (which would require more real-time action coding).
• Sabotaging town facilities (e.g. poisoning the gastrotech stalls to cause a food shortage).
• Hacking each other’s equipment or bribing mercenaries to defect. All of these can be fun but would be later expansions.
• Other PvE Encounters: Not every mission will have a player bandit encounter (in fact, it might be relatively infrequent unless the game culture is very cutthroat). To keep things interesting, we will incorporate NPC challenges as well:
• Wildlife/Creatures: The Scablands host some bizarre lifeforms (as lore suggests – e.g., maybe giant sandworms or the aforementioned Juicebox rodents, or roaming slime mold boulders ￼). Missions could trigger creature encounters that require combat or clever avoidance. Defeating a creature might yield special loot (like a rare organ or material).
• Environmental Hazards: Sandstorms, solar flares, unstable terrain (maybe your team’s rover breaks down) – these events might delay missions or reduce yield (e.g. some loot is lost in a storm) unless the team has certain skills or equipment.
• Rival NPC crews: Possibly other AI-controlled drifter crews from outside could be competing. This is akin to bandit attacks but framed as non-player prospectors. If we want more PvE, we could have random “raider gangs” that sometimes ambush expeditions (so even if players aren’t doing banditry, the world itself has dangers). This would use similar combat resolution.
• Mission Resolution and Rewards: At the moment a mission ends (time is up and any conflicts resolved), the outcome is computed on the server:
• The server will remove the mission from active list, mark the drifters as free again, and create a Mission Report (which includes loot obtained, any events that happened).
• If the mission was successful and loot was gained (and not stolen), the loot is credited to the player. Possibly we directly convert to currency (for simplicity, could say your crew sells it automatically on return). However, to give players a decision, we might instead put the loot into their inventory and then allow them to sell or perhaps use/trade it. Implementing inventory is a bit more work, but it’s doable. For MVP, an easier route: automatically sell all loot at standard prices upon return and just give currency. This completes the loop without adding an inventory UI. But we risk losing the fun of collecting items. Maybe as a middle ground, we could say common resources auto-sell, but if an artifact is found, it’s not auto-sold – it goes into a list of special finds for the player to decide (since maybe artifacts could have other uses).
• Any XP or progression for drifters could also be calculated (if we decide drifters themselves can level up or gain reputation).
• The player is then notified (if online, via UI update; if offline, next time they log in they get the results).
• Seeing Others’ Missions: The map and possibly a “Missions Board” UI will show all ongoing missions. We will update this in near real-time. Using Cloudflare Workers with Durable Objects and possibly WebSockets, we can broadcast mission start and end events. For MVP, we might skip real-time push and instead refresh mission data whenever a player opens the map or on a short interval (say every 30 seconds) to see the latest. Given Workers can handle real-time with Durable Objects (e.g. using fetch to upgrade to WebSocket within a DO to push updates to all connected clients) ￼, we might attempt a basic real-time feed for those online: it’s an advanced feature, but it can greatly enhance the sense of a live world. We’ll consider implementing a “world channel” DO that maintains a list of connected players (via websockets) and broadcasts events like “Mission X started/ended” or “Resource Y depleted/replenished”.
• Cooperative Play: While not explicitly requested, our design allows for cooperative interactions too. For example, players could agree out-of-game to scout different areas and share coordinates of finds, or one could escort another’s mission (imagine sending a guard detail to follow another team to protect them from bandits – we might not implement that initially, but the concept is possible). As the game grows, we could add features like guilds or factions, shared goals (like communal town projects), or cooperative missions (raiding a particularly tough location together). Initially, however, each mission is single-player controlled with the only interaction being via sabotage.

In summary, missions in Scablanders provide a rich tapestry of emergent gameplay: players balancing risk and reward, sometimes serving as allies and other times as adversaries. The indirect PvP keeps everyone on their toes, and PvE elements ensure there’s always a challenge even if no other player interferes.

Economy and Progression

The game’s economy is designed to be simple (no blockchain tokens, just an internal currency) but with enough facets to keep it interesting. Here’s how the economy and player progression systems work:
• In-Game Currency (Credits): This is the primary currency for all transactions. Players earn Credits by selling resources and loot obtained from missions. All prices for hiring, buying, upgrading are denoted in Credits. This currency is purely off-chain and lives in the game’s database – it’s not a cryptocurrency or token, so we avoid any crypto volatility or regulatory complexity. Think of Credits like gold in an MMO.
• Earning Credits: The main income sources are:
• Resource Sales: Common resources like metals, minerals, organics sold to NPC buyers (market prices are mostly fixed at game start, e.g. 1 unit of iron ore = 5 Credits, etc., though we could later add dynamic pricing).
• Artifact Sales/Trades: Rare items might fetch high prices; possibly the black market offers better deals for contraband artifacts.
• Mission Rewards: Some missions might have direct Credit payouts (e.g. a contract mission where an NPC pays you to deliver something).
• Passive Hire Income: As described, NFT owners earn Credits when their drifters are hired by others. This redistributes wealth within the player community and incentivizes NFT holders to participate (or at least list their drifters for hire).
• Spending Credits: Key sinks for Credits include:
• Hiring Drifters: Every mission usually incurs a hiring cost (unless using your own NFT drifter). This is a major repeated expense and transfers Credits to NFT owners (or to nothing if the merc is a non-NFT NPC, but primarily it goes to owners).
• Buying Gear/Upgrades: The shops in town will sell upgrades. For example, a better drilling rig might cost 500 Credits, a desert rover vehicle 1000 Credits, etc. We’ll plan out a progression of items/upgrades with increasing costs.
• Town Services: Possibly paying for things like a medic to heal your drifters faster, or paying the gastrotech for special buff food that enhances next mission.
• Bribes/Black Market: Engaging in banditry might require paying a bribe or fee at the black market (to find willing criminals), which could be another money sink (these fees might just vanish or perhaps go into a pool that could even fund some global event – but likely just a sink).
• Cosmetics/Customization: In the future, could allow players to spend Credits on cosmetic customization (like outfitting your favorite drifter with a new outfit in the UI, purely visual).
• Market Balance: We will need to balance the economy so that income from missions roughly matches the expenses, with a slow progression upward. Early game missions give small profit but enough to keep hiring and afford minor upgrades; later missions yield more profit but also require more investment. By adjusting resource values and hire costs, we can ensure players can’t infinitely farm without risk or cost. The persistent world also naturally balances economy: if everyone farms the best resource, it depletes, forcing players to go for lesser ones or wait for respawn.
• No Pay-to-Win: There will be no purchasable currency with real money at launch – this is not a play-to-earn or pay-to-progress scheme. Progression comes only from playing the game. The NFT integration provides some players extra earnings, but those are earnings from other players playing (a kind of peer-to-peer reward), not from outside money. So the economy is closed and game-driven.
• Progression Curve: We can define player “level” or rank perhaps in terms of total Credits earned or a separate XP. It might be nice to have a leveling system for the player’s account, unlocking new content (like at rank 5 you can go to a further region or take on missions of higher difficulty). But an explicit XP system might be unnecessary if progression is organic through upgrades. We can start without one and gauge if a “reputation” or “license” level is needed to gate content.
• Upgrades and Tech Tree: As mentioned in the core loop, players can buy upgrades. To flesh this out:
• There could be categories: Transport, Tools, Team Capacity, Personal Skills.
• For example, Transport Tier 1 = a basic rugged buggy (cut travel time by 10%). Tier 2 = a hovercraft (cut travel 30%). Tier 3 = a small spaceship shuttle (maybe allows missions to other nearby planets or very fast travel).
• Tools might include scanners (increase chance to find hidden loot or reveal resources without scouting too closely), weapons (given to your team to boost combat stat when you dispatch them), protective gear (reduces risk from hazards).
• Team capacity can allow more drifters per mission or more concurrent missions.
• Personal skill might be a minor buff like the player character themselves is abstractly learning – e.g., “Logistics Management: +1% loot yield per level” or something – but that might complicate things. Could skip for now.
• We will present upgrades in the UI as things to buy at shops. The spaceport NPC might sell vehicles, the hardware store sells tools, etc.
• This gives players long-term goals to save for.
• Inventory (if implemented): If we allow players to hold onto certain loot instead of auto-selling, we need an inventory UI and storage limits. Possibly the player’s warehouse in town could hold a limited number of items (upgradable for more capacity). They might choose to keep an artifact rather than sell it, perhaps waiting for a better price or using it in a quest later. This is a nice-to-have feature; for MVP, auto-selling common loot is okay, but we likely should implement at least basic inventory to handle unique items. We can simplify by saying all common resources convert to Credits on return, and only special artifacts go to inventory.
• Example Flow of Economy: A new player starts with, say, 100 Credits. They hire a cheap drifter for 50, go out and bring back some scrap worth 80 Credits. Now they have 130. They hire two drifters for 100 to go to a farther site, come back with 200 Credits of ore. Now profit 100, total 130 -> 230. They spend 200 on a scanner upgrade, now have 30 left but next mission they can find better loot. And so on. Meanwhile, the NFT owner of those drifters got paid those hire fees (50 and 100 in this example) into their account. If that owner logs in, they now have 150 Credits earned without doing anything, which they can then use to play or invest (maybe hire other drifters for their own missions).
• Managing NFT Owner Balances: We should clarify that NFT owners who aren’t active players still accumulate currency. We will have a record in the database linking NFT -> unclaimed Credits. The first time an owner logs in, we create a player profile for them and credit all those. If an NFT is sold to another person (changes wallet), we need to handle that too: ideally, if the NFT has unclaimed earnings and is sold, those earnings should probably go to the previous owner (since they were the owner at the time of hires) – but if they never logged in, we have it under the old address. If the NFT transfers, new hires should pay the new owner. We might decide a cutoff: earnings accrued stay with the address, and the new owner starts fresh. This is an edge case probably not critical for initial implementation but worth noting for the future. We might simply track by address, not by NFT, i.e., when a hire happens, find current owner address and credit them immediately. That way it’s always correct even if ownership changes multiple times. Yes, that’s better: each hire event will look up the current owner (via on-chain lookup or cached data) and instantly credit that address’s balance. So we don’t actually need to store per-NFT pending values, just credit accounts live. If the owner never logs in, their balance sits associated with their address in our system until they do (we can have a table Address -> Balance). This simplifies handling transfers.
• On-chain vs Off-chain: All these Credits are off-chain. We might implement a system in the future to allow withdrawing Credits to a blockchain token or vice versa, but that’s out of scope now. The economy exists solely within the game’s servers. The NFT integration only uses the blockchain to verify ownership; all game transactions happen off-chain.

To ensure the economy is fun, we will playtest reward vs cost numbers and adjust the tuning. The aim is for players to feel a steady progression without hitting a paywall or zero-sum. The NFT hire payments essentially redistribute wealth from active players to NFT holders; since NFT holders can also be players, many will reinvest that money in the game, circulating it. There’s a possibility that pure NFT holders (who don’t play) accumulate a lot of currency – but if they’re not spending it, it’s inert. If they do join later, they get a jump start, which is a perk of having an NFT but hopefully not game-breaking given it took other players’ expenditures to create that situation.

Technical Architecture

This section outlines how we will build Scablanders, covering both the front-end (client) and back-end (server), and how the various pieces fit together:

Front-End (Client)
• Framework: We will use Phaser 3 (JavaScript/TypeScript) for the game client. Phaser is a well-established HTML5 game engine for 2D games, known for its fast performance and ease of use for browser games ￼. It provides features like a game loop, sprite rendering, animations, input handling, and basic physics – which will be handy for implementing an interactive map and UI elements. We will write the game logic in TypeScript for type safety.
• Game Canvas: The game will run on an HTML5 canvas element managed by Phaser. We’ll have a top-down map view of the Scablands (likely a stylized 2D map, either tile-based or an image with coordinate system). On this map, we will render:
• The mining town (home base) at the center.
• Resource nodes (icons that appear when discovered).
• Mission markers (moving icons for expeditions).
Possibly we’ll show a fog-of-war overlay for unexplored areas (which can be revealed as the player scouts).
• User Interface: Phaser can handle interactive UI or we may use HTML overlays for some static panels. Key UI components:
• Map Screen: showing the world and missions.
• Town Screen: could be a different view or an overlay on the map when zoomed into town. Here the player can see different buildings (each representing an action: e.g., a “Mercenary Hall” button, “Market” button, “Black Market” etc.). We might implement town as a simple menu UI rather than an explorable location initially.
• Menus/Popups: e.g., a list of drifters to hire (when clicking Mercenary Hall), a mission planning popup (select target and team), a report popup (show mission outcome).
• Wallet Connect UI: a button to connect wallet. Likely using a Web3 provider (MetaMask) that, when clicked, triggers the Ethereum provider to request signature for login.
• HUD: Display current Credits balance, maybe player name, etc.
• State Management: The client will maintain some state like the list of known resources (from scouting results), current missions player has dispatched, etc., but the source of truth is the server. We’ll fetch data as needed:
• On login, fetch player profile (balance, owned drifters, etc.).
• Fetch initial town state (e.g., prices, available upgrades).
• Fetch list of available mercenaries (with their stats and cost).
• Fetch known resource nodes (for that player).
• Fetch active missions (for all players) for the map display.
We’ll likely create a series of REST API endpoints to retrieve these, or one bulk endpoint on login to get initial game state snapshot.
• Real-time Updates: If using WebSockets or Server-Sent Events for live updates (like new missions, mission completions, resource depletion), the client will maintain a connection to receive those and update the UI accordingly (Phaser can update the game objects like remove a resource icon or add a mission icon). If not using real-time, the client will poll periodically (e.g., every 30s call an API for updates).
• Cloudflare Vite Plugin: We will integrate the build process with Cloudflare’s Vite plugin ￼ ￼. This means we can run npm run dev to spin up a development server that serves our Phaser app and also executes our Cloudflare Worker backend locally (in a simulator). The plugin’s dev server proxy will let us develop the front-end and back-end together seamlessly – when the client calls an /api/\* route, it will actually invoke our Worker code, allowing end-to-end testing during development ￼. The plugin also handles bundling: vite build will produce both the static assets (JS/CSS for the client) and a Worker script for the backend in one go ￼. We’ll use this to deploy the app to Cloudflare’s edge. Essentially, our codebase will be a single repository containing:
• A front-end Phaser game (in something like src/game),
• A back-end Cloudflare Worker (in api/ perhaps, since Cloudflare’s example used api/ directory for server code ￼).
• The Vite config with @cloudflare/vite-plugin will ensure that static assets are served and that our Worker can serve the API routes in production.
• Hosting: The final app will be deployed on Cloudflare’s network. The static front-end (HTML file, bundled JS, images) can be served directly by the Worker (the Vite plugin can treat certain directories as static assets). Cloudflare Workers can also serve as an origin for these, or we might use Cloudflare Pages (which can host static assets and a Functions for dynamic part). But since the prompt says we’ll host in Workers, likely we’ll just use the Worker for everything. The Cloudflare Worker can be configured to handle different routes: serve the game HTML on / and static files, and handle API under /api/. The Workers runtime being globally distributed will make sure the game has low latency for players worldwide.
• Phaser and Asset Loading: We might need to load images for drifter avatars, map tiles, etc. These could be stored in our project or fetched from IPFS/URLs (for NFT images). For performance, we might download the needed NFT images and include them or cache them. Alternatively, we use a placeholder or generic sprite for each drifter and only show unique art in a profile popup due to bandwidth. This is a detail to sort out – to keep it simple, we might not show full NFT art in the game map (since some are very detailed), but maybe show a small thumbnail or just the name, and have a detail view where the full image can be loaded on demand. We will ensure the art style is consistent (we can incorporate the NFT images or their style for character portraits).

Back-End (Cloudflare Workers)
• Runtime: Cloudflare Workers will run our server-side logic on the edge. The code can be written in TypeScript as well (which will be compiled to JS and run on the Worker). We’ll use the Durable Objects (DO) feature for state. Each DO is like a single-instance mini-server that can hold data in memory (with optional persistent storage) and handle requests sequentially, guaranteeing no race conditions.
• Durable Objects Design: We will create at least one Durable Object class, likely called something like World DO or Game DO. This DO will be responsible for the global game state and coordination. Since the world is not extremely large and number of simultaneous actions at start might be manageable, one DO may suffice. The WorldDO will store:
• The resource nodes: their locations, types, current quantity, next respawn time if depleted.
• The active missions: a map of mission ID -> mission data (including the involved players and drifters, target, start/end times).
• The town stats: e.g., prosperity level, security level, which could be derived from delivered resources or number of attacks.
• Possibly the player registry: mapping player (wallet address or an internal player ID) to their data like balance, known resources, owned drifters. (We might offload detailed player data to another DO per player for scalability, but initially, we can keep it here or in KV. If the game scales, moving per-player data to individual DOs could be wise to distribute load. Cloudflare allows many DO instances addressing by an ID.)
• The NFT ownership cache: so we don’t query the blockchain every hire, we can keep a mapping of drifter ID -> current owner address, updated whenever a player logs in or we have a background job updating from OpenSea. Alternatively, each hire can query a cached mapping in KV. We’ll figure caching to avoid rate limits on APIs.
• The DO will also manage timers for missions if using alarms.
We might also implement separate DOs:
• e.g., a PlayerDO for each player address to handle their inventory and currency operations (so that personal transactions don’t all queue on the world DO). The World DO could delegate certain things to Player DOs. However, given the complexity, for MVP one DO is simpler. A single DO can definitely handle dozens of players; if we anticipate hundreds+ simultaneous players, a single DO might become a bottleneck because it processes events one at a time. In that case, splitting might be needed. Perhaps:
• WorldDO handles global stuff (resources, missions).
• PlayerDO per player for personal stuff (balance, etc.), which can be woken up by world DO or via direct API calls when needed.
• But cross coordination (like mission involves multiple players) would need one to coordinate – which again suggests the World DO should orchestrate missions.
Initially, we’ll proceed with a single DO for simplicity, and design it such that it can be refactored to multiple later if needed.
• API Endpoints: The Worker will expose various endpoints (likely under an /api prefix). For example:
• POST /api/auth/siwe – to handle Sign-In With Ethereum. The flow would be:
• Client requests a nonce from server (server might have an endpoint to get a SIWE message).
• User signs the message in wallet, returns signature to server at /api/auth/siwe.
• Server verifies signature (using the public address recovered) and if valid, creates a session (could be a JWT or just sets a cookie or returns an auth token).
• We might not need a full OAuth style session since the wallet signature itself can be used each time or short session token can be issued. Possibly easier: after login, the client can include the signature or token in subsequent requests (maybe as a header or cookie).
• The Worker can set a secure httpOnly cookie as a session, stored in KV or just JWT signed (since Cloudflare Workers can sign a JWT). However, we can also go tokenless by requiring each request to be signed, but that’s overkill for a game. Better to establish a session.
• We’ll store the logged-in address in the Durable Object or KV mapping token -> address for quick auth checks.
• Citation: The SIWE standard shows how an Ethereum account can auth with a backend ￼, and we will implement accordingly.
• GET /api/profile – returns the player’s info: balance, list of owned drifters (IDs), maybe their current known resource nodes, etc.
• GET /api/mercs – returns list of mercenaries available to hire, with their stats and hire cost and an indicator if the player owns it (so cost is 0 or something for those).
• POST /api/mission/start – as discussed, to initiate a mission. Payload includes target and selected drifter IDs.
• POST /api/mission/intercept – to launch a bandit intercept on another mission.
• GET /api/mission/status?missionId=X – could get status or outcome of a mission. In many cases we might push this, but having an endpoint to poll is fine.
• GET /api/world/active-missions – returns summary of all ongoing missions for map display (could be filtered by region if needed).
• GET /api/world/resources – returns resource nodes (maybe only those that are discovered by the requesting player; the server can filter based on player’s scout history).
• POST /api/scout – to initiate a scouting mission (or we handle it through general mission endpoint with a type).
• POST /api/sell – if we allow manual selling from inventory, this would specify item and quantity to sell to an NPC, and server adjusts balance accordingly.
• GET /api/town – maybe returns town status and prices, etc., if needed.
• POST /api/upgrade – purchase an upgrade (vehicle, tool, etc.), which deducts money and flags that upgrade as owned (impacting mission logic).
The API will use the Durable Object to perform the operations. Cloudflare’s Workers can route requests to a specific Durable Object instance by its ID or a namespace. We likely have one well-known ID for the World DO (like derived from a constant name or something). Requests that need to interact with game state will call methods on that DO. For example, when mission/start endpoint is hit, the Worker script will locate the World DO instance and send it a message (like env.WORLD_DO.idFromName("global") to get the stub, then call stub.fetch or stub.submitMission(…)). The DO code then handles it, updates state, etc.
• Mission Timers: Cloudflare Durable Objects have an alarm API (basically a scheduler) that can be set to wake the DO at a certain time in the future. We can utilize this for mission completion. When a mission starts, we set an alarm for its end time. When the alarm triggers, the DO knows it’s time to resolve that mission. It will compute outcome, update state, and possibly send a notification (could store the result for when player requests it, and/or push via WebSocket if connected). If an intercept occurs before the time, that intercept handling could either immediately resolve the mission (if we decide ambush happens en route back which might be near end) or it could shorten the mission effectively. Simpler: handle it at end time regardless.
• WebSockets (optional): Cloudflare Workers support WebSockets (especially via Durable Objects to maintain connections) ￼. We could implement a DO that manages WebSocket connections for each player to push events. For example, whenever a mission finishes or a new mission is started (especially relevant if Player A’s mission gets ambushed by Player B, Player A should get that info promptly), the server can send a message to the relevant players. Given time constraints, we might skip this and use polling of endpoints for updates. But to future-proof, we’ll keep the code structure such that adding WebSocket updates is possible. If implementing, likely one DO (like WorldDO itself) keeps track of all connected clients and broadcasts certain events, or separate LobbyDO that gets events forwarded from WorldDO. Cloudflare blog examples show using DOs as message routers for games ￼.
• Data Persistence: The Durable Object’s state can be persisted via this.state.storage.put() calls. We will periodically (or after each significant change) save key data:
• Save resource nodes (so if worker goes down, we know which are depleted).
• Save town stats.
• For missions, we could save active missions, but since they are short-lived, if a restart happened mid-mission we could either fail them or restore them. It might be acceptable to just fail missions if a rare outage occurs (with maybe a refund), but we can also store them to resume after a crash (persist start time and such).
• Save player balances and upgrades. Alternatively, player balances could be in an external durable storage like D1 if we had many players – but DO storage is likely fine since it can hold lots of data (limit is quite high per DO, like hundreds of MB).
• Save NFT owner mappings if needed.
We also might use Cloudflare KV (a global key-value store) for some data that doesn’t require strong consistency. For example, caching NFT ownership: a KV store mapping drifterID -> ownerAddress updated whenever we detect a change. This would allow quick lookup from any edge location without always hitting the DO. But any writes should still validate via DO to avoid race conditions. Another usage: session tokens storage, though we can also use signed tokens instead of storing sessions.
• Wallet Authentication Implementation: As mentioned, we will implement Sign-In with Ethereum (SIWE). The flow: 1. The client requests a nonce/message from server (optional step: we can generate a random nonce and construct a SIWE message like “Log in to Scablanders with wallet X, nonce Y”). 2. User signs it in their wallet. 3. Client sends signature to server. Server verifies signature using the Ethereum public key recovery to get the address. If it matches the address in the message and nonce is correct, auth succeeds. We then either set a session cookie or return a JWT containing the address. 4. All subsequent requests will include the session (cookie or token). The Worker will verify and attach the address to the request context.
We might use an open-source library or example for SIWE to avoid pitfalls ￼. There is a reference implementation in TypeScript we can likely use. Cloudflare Worker environment doesn’t allow direct TCP, but we don’t need that – verifying a signature is pure computation (elliptic curve recovery), which can be done with a library like ethers.js or siwe package.
• NFT Ownership Check: When a player authenticates, we call an API to get their NFTs. We have the player’s Ethereum address from SIWE. We can call, for example, OpenSea API’s “Get assets for owner” endpoint (with collection filter) or use an Alchemy API call to get NFTs for that owner. We’ll need an API key likely for these services due to rate limits. Alternatively, if we have the NFT contract address, we could query directly via an Ethereum node (Cloudflare has an Ethereum gateway we could use ￼, or use Etherscan’s API). A quick approach: use OpenSea if they still have a public API by 2025. If not, Moralis or Alchemy are alternatives. We will implement it such that on login, the server fetches the list of drifter IDs the user owns and stores it in their profile data. This way, the server knows which mercenaries shouldn’t charge a fee and where to send hire payments.
We will also possibly preload a mapping of all drifters to owners on server startup (especially if we anticipate scanning each login may be slow). Since NFT owner changes aren’t too frequent, we could periodically refresh a global map from OpenSea. But it might be fine to fetch on demand.
• Cloudflare Workers Constraints: We must be mindful of the 50ms CPU time limit per request (though Durable Object fetches can go longer, especially if waiting on I/O). We should avoid heavy computations in a single tick. Our use case is light (some calculations, DB read/writes, external API calls). External fetch calls (like NFT API) are allowed but count toward a 30s request limit. We’ll design things to mostly be quick. Missions are resolved via events or timers, not by holding connections open.
• Testing and Debugging: We’ll use the local dev environment via wrangler dev or the Vite plugin’s dev server to test flows. We can simulate two players by using two browser windows (since authentication is wallet-based, maybe we’ll have two test accounts). We will also write unit tests for mission outcome calculation logic (maybe using a deterministic function to simulate battle results for given stats).
• Deployment: Using wrangler publish will deploy the Worker and assets to Cloudflare’s network ￼. We will set up the appropriate wrangler configuration (as shown in Cloudflare’s example, including compatibility date, etc.). The Vite plugin ensures our static assets are uploaded (perhaps to Workers KV for asset serving behind the scenes). The end result is one public URL (maybe scablanders.game or a workers.dev subdomain) where the game can be accessed. Because all state is in Durable Object, all edge instances of the Worker will interact with the same DO (identified by its name/ID), providing consistent global state.

Implementation Plan

Now we break down the development tasks into a step-by-step plan. This structured plan can guide the Warp agent (our AI coding assistant) to build the game: 1. Project Setup:
• Initialize a new project using Cloudflare’s template for Vite+Workers. For example, run npm create cloudflare@latest scablanders -- --type=workers or the appropriate command ￼. Choose a template (we might start with a basic JavaScript template since we’ll integrate Phaser ourselves).
• Install dependencies: phaser (for front-end), ethers or siwe (for signature verification), any needed polyfills for crypto libs in Workers, etc.
• Configure vite.config.js to use @cloudflare/vite-plugin ￼. This will set up the integration of client and Worker code.
• Set up wrangler.toml for the project with necessary settings (name, DO bindings, KV binding if any, etc.) ￼. Define a Durable Object class binding for the world state.
• Verify that npm run dev starts both the dev server and that a basic Worker responds (perhaps implement a test route).
• Set up TypeScript config to allow shared code between front and back if needed (though likely they’ll be separate). 2. Define Data Models and Durable Object:
• Design the TypeScript interfaces or classes for core game data: e.g. ResourceNode, Mission, DrifterProfile, PlayerProfile, Upgrade.
• Implement the Durable Object class WorldDO (and any other DOs needed):
• Give it a storage schema for persistent fields: maybe a key for resources, a key for town, etc.
• Add an initialize() method to load data from storage on startup (like restore resource list, etc.).
• Add methods to handle actions: e.g. handleStartMission(request) to start a mission, handleCompleteMission(id) for when alarm triggers, handleHire(drifterId, hiringPlayer), handleScout, etc.
• Also methods for read operations: handleGetActiveMissions(), handleGetResources(player), etc.
• Implement the Durable Object fetch(request) to route incoming subrequests to the appropriate handler based on path (e.g., if request.url.endsWith(”/mission/start”), call handleStartMission).
• Use this.state.blockConcurrencyWhile(async ()=>{ ... }) if doing any initialization to avoid race conditions.
• Plan to use this.state.storage to save snapshots of world state periodically or after significant changes. For example, when a resource is depleted or when an upgrade is purchased, update storage.
• Setup alarm handling: this.state.setAlarm(scheduledTime) when a mission starts. And implement an alarm() handler in the DO class that goes through due missions.
• Ensure that the DO has access to environment bindings like KV (if used) by defining them in env parameter. 3. Implement Authentication (Wallet Login):
• Create an endpoint in the Worker (not DO, but the main module script) for login. Possibly GET /api/auth/nonce to get a nonce and POST /api/auth/verify to verify signature.
• Use the SIWE format message. You can use the siwe npm package to help parse/validate messages, or manually build a message and use ethers.utils.verifyMessage.
• When signature verified, establish a session. Simplest: generate a random session token (or JWT) and store a mapping in a KV store from token -> address (with expiration). Or use Durable Object to store sessions (less ideal since DO might not handle too many).
• Alternatively, use a Cloudflare Durable Object as a session manager (not necessary here). A popular way is to return a JWT signed with a secret containing the address (so we don’t have to store session server-side at all). Cloudflare Workers can use HMAC or ES256 to sign JWT.
• Given we want persistent login, a cookie might be nice. We could set a cookie AuthToken with the JWT.
• Implement middleware in our Worker fetch handler to check for auth on protected routes (anything under /api except auth routes). If token/cookie is present, verify it and extract address.
• If verified, attach the address (and maybe a Player object from DO if needed) to the request handling context.
• On login success, also do an NFT ownership fetch (next step) so we immediately know which drifters the user owns.
• For development, allow an “unauthenticated mode” perhaps with a dummy address if needed for testing without wallet, but ideally test with actual wallet signatures. 4. Integrate NFT Ownership Check:
• Write a utility function to fetch NFT ownership for a given address. Possibly create a free API account (Alchemy or use OpenSea’s public API if available). For example, call Alchemy’s https://polygon-mainnet.g.alchemy.com/v2/<key>/getNFTs/?owner=<addr>&contractAddress=<fringeContractAddress>. Or if on Ethereum mainnet, similar endpoint.
• Parse the response to get a list of token IDs the user owns.
• Store this in the Player’s data (e.g., in a set of ownedDrifters).
• Also, update a global map of drifter ownership in memory (or KV). This will allow when any hire happens, we know where to credit. Perhaps simplest: when game starts, do one fetch of all owners of all drifters (if API allows). But that could be thousands of entries – maybe not needed if we just query each user on login.
• However, for paying owners who are offline: if Bob hires drifter #123, we need to know #123’s owner (say Alice) to credit her. If Alice never logged in, how do we know it’s her? We must query an ownership registry at that moment. So maybe on every hire we do a quick lookup in our cached map or call an API to get the owner of that token ID.
• We can maintain a cache: every time we encounter a drifter we haven’t cached or if the cache is older than X minutes, we fetch the owner. The NFT data doesn’t change often, so caching is fine.
• Implement a function getDrifterOwner(drifterId): check local Map, if not present or stale, call external API to get owner, update cache. (Some NFT APIs let you query by token ID directly for owner.)
• Cloudflare’s Ethereum gateway could also be used: we can call a read of ownerOf(tokenId) on the contract using Cloudflare’s Ethereum node ￼. That’s actually straightforward and avoids third-party API. Cloudflare provides an Ethereum RPC at https://cloudflare-eth.com for mainnet. Using ethers.js, we can connect to that (should be allowed) and call the contract’s ownerOf. Given we have the contract address and ABI for ERC721, it’s a single call. That might be robust. We’ll consider that: it’s decentralized and doesn’t require API keys, but it has rate limits too (not sure how strict).
• For now, plan to integrate a known solution (maybe Alchemy’s NFT API for simplicity). 5. Back-End Game Logic:
• Implement the mercenary listing endpoint: GET /api/mercs. This should:
• Query our drifter list (which could be static or loaded from a JSON of all NFT traits).
• For each drifter, determine if it’s currently free or on a mission (the WorldDO knows active missions and which drifters are in use).
• Determine the hire cost (we might assign a base cost per drifter based on their skill or rarity, or a flat rate). Possibly each drifter has a level or rarity and we set cost accordingly.
• If the requesting player owns that drifter, mark cost as 0 (or “owned”).
• Return the list (perhaps limited or paginated if large).
• Implement POST /api/mission/start:
• Authenticate player (address from session).
• Parse input (target location, drifter IDs).
• Validate: ensure player has enough Credits for hire fees (sum of those drifters’ costs where they are not owner). If not, error.
• Ask WorldDO to start mission: likely by calling WorldDO.startMission(playerAddr, drifterIds, target). We pass necessary info.
• In WorldDO’s startMission, do:
• Reserve those drifters (check none are busy).
• Deduct player’s Credits (the DO might need to have player balances; if we had per Player DOs, we’d call that, but we can just keep a map of balances).
• For each drifter hired that the player doesn’t own, determine owner and credit that owner’s balance with the fee ￼ (since payment goes to the owner; if the owner is the same as player, skip).
• Create a mission object with unique ID, status = active, compute endTime = now + duration.
• Possibly compute an initial outcome or store a placeholder outcome.
• If using DO alarm: set an alarm for endTime.
• If immediate feedback needed, we can return the mission ID and ETA to the client.
• Return success to client (maybe include mission ID and ETA).
• The client will then start showing it on the map.
• Implement GET /api/world/active-missions:
• Simply call WorldDO to get a list of active missions with minimal info (e.g., an array of {id, x, y, eta, maybe team size or something}).
• The DO returns those and the Worker returns to client. The client can then render markers for each.
• Implement POST /api/mission/intercept for bandit attacks:
• Similar to startMission in structure. Validate player has funds to hire bandits, etc.
• Call a DO method like startIntercept(attackerAddr, targetMissionId, drifterIds).
• In DO, find the target mission. If it’s still active and not too close to finishing (we might enforce a cutoff), mark that mission as having an intercept incoming and record the attacker and their crew stats.
• Possibly adjust the mission’s endTime if needed (maybe an ambush might cause it to end slightly later or earlier).
• We probably don’t resolve the combat immediately; we can wait until mission end to resolve both at once.
• Alternatively, we could resolve intercept at the moment intercept is launched, effectively ending the mission early. But that gives no chance for defender to respond anyway, so timing doesn’t matter much except for if multiple interceptors try the same mission. We should probably only allow one intercept per mission (first come first serve). Once an intercept is set, others attempting should get a “mission already being intercepted” error.
• Return success to attacker. They will then just await outcome (we might list their bandit mission under their missions as well).
• Mission Resolution (Alarm or Poll):
• When a mission’s time is up, the DO’s alarm triggers. The DO will:
• Check mission details, see if there was an intercept set.
• Roll for outcomes:
• If intercept exists: compare stats of crews, generate a random factor, decide winner.
• If bandits win: mark mission as looted, assign loot to attacker instead of defender.
• If defenders win: proceed normally.
• If no intercept: just proceed with normal resolution.
• Determine loot: based on resource type and perhaps drifter scavenging skill. For simplicity, we can precompute expected loot count on mission start (like if going to a known resource node with X quantity, they’ll bring back maybe X or a portion). But random artifacts might drop.
• Update resource node: deduct the amount taken. If fully mined out, mark it depleted (and maybe set a respawn timer for it in the future).
• Update players’ balances:
• Add currency to defender for the loot value (if we auto-sell loot).
• Or add items to defender’s inventory list (if not auto-selling). If we auto-sell, each resource type has a credit value and we sum it up.
• If bandit succeeded, then attacker gets the currency/items instead.
• Maybe give a small XP to drifters or players if we have that (not crucial for MVP).
• Mark mission as completed (remove from active).
• If players are online, we can send them a WebSocket message with the outcome or at least mark something so that next time they call status it’s ready.
• Store any important info (maybe a log of mission for debugging).
• If using polling: the client of the player will probably be asking for mission updates. We can implement GET /api/mission/result?missionId= that the client calls when mission time is elapsed, which then returns the outcome details (the DO can compute if not already done or fetch stored result).
• Using alarm is nicer as we compute exactly at the right time. We should be careful that Cloudflare DO alarms are not super precise if many alarms cluster, but it should be fine.
• Implement GET /api/profile (or part of login response) to get the player’s current balance, inventory, and upgrades.
• The DO or a KV can store player balances. Likely the DO holds a Map of address->balance. We’ll ensure to credit and deduct from this consistently.
• Inventory if any can be a list of item IDs or resources.
• Upgrades can be stored similarly (e.g., a set of upgrade ids the player purchased).
• Implement POST /api/upgrade:
• Check the requested upgrade, verify cost and prerequisites, deduct cost, mark upgrade as owned for player.
• If the upgrade affects gameplay (e.g., faster missions), ensure the DO uses that in calculations (like store an attribute in player profile like speedMultiplier).
• Implement GET /api/world/resources:
• The DO should filter resources by what the player has discovered. We need to track what each player knows.
• When a scout mission completes, we should add those coordinates to the player’s known list.
• We can store playerProfile.discoveredNodes: Set<nodeId> or similar.
• Then this endpoint can return the subset of resource nodes that are either (a) globally visible or (b) in the player’s discovered set. Possibly some things might be globally visible like the nearest area around town always known.
• This data allows the client to render resource icons appropriately.
• Consider security: ensure that a player can’t, for example, start a mission with someone else’s address or access another’s data. Our auth should prevent that by scoping all DO calls to the authenticated address. Also, verify that when they request resource info or mission results, it only returns what they’re allowed to see (though missions are mostly public, except maybe exact loot details). 6. Front-End Integration:
• Build the login flow in the client:
• Use web3 provider (MetaMask) to request accounts and sign message. We’ll probably utilize the window.ethereum API. The agent might need to include a script or use an existing library for SIWE.
• After signature, call our /api/auth/verify endpoint. On success, the server might set a cookie or return a token.
• Once logged in, call /api/profile and /api/world/resources and /api/mercs to get initial data.
• Implement the Map scene in Phaser:
• Draw the map (we might use a simple image or generate some terrain).
• Represent resources: for each resource node in initial data, place an icon (like a rock for ore, a plant for organic, etc.). Possibly these are static images, we can have a small sprite atlas.
• Represent missions: create a container or sprite for each mission marker. We can update their position over time (linearly interpolate from start to target based on mission progress percentage). Since missions take minutes, the movement will be slow – but visible. We might update positions on each game tick by checking current time vs start/end.
• If not simulating continuous movement, we could also just show them at target or a generic “in-progress” indicator. But movement adds life.
• Town and Menus:
• Create UI for hiring mercs: perhaps when clicking town or a “Hire” button, open a list. This could be an HTML overlay (maybe easier for long lists with scroll) or done in Phaser with bitmap text. Using HTML/CSS might be faster for such interfaces. Phaser can incorporate DOM elements or we can use regular HTML modals on top of canvas.
• Show drifter details when selecting from list. Provide a “Hire” button.
• On hire selection, allow choosing mission target. Possibly we let the player click a resource on the map after hiring to assign that mission, or we could have a form where they pick from known resource list.
• For simplicity: workflow could be – click on a resource icon on map, which opens a dialog “Send mission here?”, then choose which drifters to send (opening hire menu filtered maybe). Or vice versa: pick drifters then target.
• We can refine UI/UX as we test.
• Scouting: maybe a button “Scout unknown areas” which then asks which direction or area. We could have predetermined sectors (N, S, E, W of town) to scout, or let them click an undiscovered region on map, which triggers scout mission.
• Displaying missions:
• The player’s own active missions could be listed in a small panel (with their status).
• Other players’ missions could show on map as mentioned. Possibly as generic icons or maybe colored by player (though identifying player maybe by name tag).
• Could allow on clicking another’s mission icon an option “Ambush” if you want to intercept. That would open the bandit hire UI.
• Bandit hire UI:
• Very similar to normal hire, but initiated via another’s mission. When a user chooses to ambush, we’ll call the intercept API.
• Maybe require confirmation (“Are you sure you want to intercept PlayerX’s mission? This will cost X Credits to hire bandits.”).
• Upgrades UI:
• A shop screen listing available upgrades with cost and “Buy” button.
• After purchase, update the player’s stats (e.g., show that they have a vehicle).
• Notifications:
• We need to inform players of important events:
• Mission result – success/fail/looted. We can show a popup or message in an on-screen log.
• If they’re online when ambushed: “Alert: bandits attacked your expedition!” perhaps.
• Could also have a log of recent global events (like “Global: Resource X was depleted” or “Town upgrade completed”).
• Implement a simple notification system in client that can display messages from server events or after polling.
• Wallet integration on client needs to handle if user declines or if no wallet – in which case we might allow a read-only mode or a guest mode (not really needed, likely require wallet to play if NFTs involved). 7. Testing & Iteration:
• Start the dev server and test logging in with a wallet (we’ll need to test this in a browser with MetaMask or a similar provider).
• Use two different accounts in two browser instances to simulate two players. Test hiring drifters, launching missions, intercepting.
• Ensure that when one mines a resource, it disappears for the other on next refresh.
• Test NFT owner earning: maybe cheat by simulating a known NFT and having one player hire it, then check the owner’s balance.
• Fix any bugs in state consistency (e.g., double hiring same drifter, etc.).
• Optimize as needed (e.g., if listing all mercs is slow, implement pagination or limit).
• Ensure persistence works: try restarting the dev server and see if state was saved (Durable Object storage should persist between sessions in dev if not reset, but might need testing with wrangler dev in remote mode or publishing to a staging environment). 8. Deployment:
• Once satisfied, run npm run build and then npx wrangler deploy to publish the Worker and assets to Cloudflare ￼.
• Configure the domain (maybe a workers.dev subdomain initially or custom domain if provided).
• Test the live deployed game with a wallet. 9. Post-MVP Enhancements (planned for future after initial build):
(These are not implemented immediately, but kept in mind for future iterations once the core game is running.)
• Implement more direct player interaction (e.g. PvP duels, town takeover scenarios) as per interest #3.
• Introduce more variety in missions and possibly cooperative missions or events (world bosses like the giant creature event ￼).
• Expand the world to other areas (perhaps beyond the Scablands to jungles of “Iris” or even space missions) once spaceport upgrades.
• Consider integrating an on-chain reward or use the NFTs more deeply (maybe a token or allowing NFTs to accrue upgrade points). But careful to maintain game balance and simplicity as desired (#4).
• Continuously balance the economy and perhaps create sinks like cosmetics or limited-time events to ensure Currency doesn’t inflate endlessly.
• Enhance graphics and add sound (Phaser can handle audio) to increase immersion.

By following this implementation plan, step by step, we will construct the Scablanders game in a structured manner. The Warp agent can systematically tackle each of these tasks: setting up the environment, coding the backend logic, creating the front-end scenes and UI, and integrating them together. Testing each piece as we go will ensure the final product is stable and fun.

Throughout development, we will reference the Fringe lore to keep the flavor right – from item descriptions to character dialogs – using the compendium as needed to name things consistently in the Fringe universe. The end result will be a living, breathing web game that blends the worlds of casual strategy and the Fringe sci-fi lore, delivered entirely through Cloudflare’s platform for a smooth, scalable experience.

Sources:
• Fringe universe background and drifter lore ￼ ￼
• Scablands setting and resource lore ￼ ￼
• Cloudflare Workers and Vite integration ￼
• Durable Objects for game state ￼
• Ethereum wallet login (SIWE) on Cloudflare ￼
